{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\Brian\\\\Projects\\\\SoundWaves\\\\sound-waves\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Brian\\\\Projects\\\\SoundWaves\\\\sound-waves\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport axios from 'axios';\nimport { Logger } from '@oceanprotocol/squid';\nexport function formatBytes(a, b) {\n  if (a === 0) return '0 Bytes';\n  var c = 1024;\n  var d = b || 2;\n  var e = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  var f = Math.floor(Math.log(a) / Math.log(c));\n  return parseFloat((a / Math.pow(c, f)).toFixed(d)) + ' ' + e[f];\n}\nexport function arraySum(array) {\n  return array.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n}\nexport function streamFiles(ipfs, files) {\n  return new Promise(function (resolve, reject) {\n    var stream = ipfs.addReadableStream({\n      wrapWithDirectory: true // progress: (length: number) =>\n      //     setFileSizeReceived(formatBytes(length, 0))\n\n    });\n    stream.on('data', function (data) {\n      Logger.log(\"Added \".concat(data.path, \" hash: \").concat(data.hash)); // The last data event will contain the directory hash\n\n      if (data.path === '') resolve(data.hash);\n    });\n    stream.on('error', reject);\n    stream.write(files);\n    stream.end();\n  });\n}\nexport function pingUrl(_x) {\n  return _pingUrl.apply(this, arguments);\n}\n\nfunction _pingUrl() {\n  _pingUrl = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(url) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return axios(url);\n\n          case 3:\n            response = _context.sent;\n            if (response.status !== 200) Logger.error(\"Not found: \".concat(url));\n            Logger.log(\"File found: \".concat(url));\n            return _context.abrupt(\"return\", true);\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](0);\n            Logger.error(_context.t0.message);\n\n          case 12:\n            return _context.abrupt(\"return\", false);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 9]]);\n  }));\n  return _pingUrl.apply(this, arguments);\n}\n\nexport function readFileAsync(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onerror = function () {\n      reader.abort();\n      reject(new DOMException('Problem parsing input file.'));\n    };\n\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n\n    reader.readAsArrayBuffer(file);\n  });\n}","map":{"version":3,"sources":["C:/Users/Brian/Projects/SoundWaves/sound-waves/client/src/utils/utils.ts"],"names":["axios","Logger","formatBytes","a","b","c","d","e","f","Math","floor","log","parseFloat","pow","toFixed","arraySum","array","reduce","streamFiles","ipfs","files","Promise","resolve","reject","stream","addReadableStream","wrapWithDirectory","on","data","path","hash","write","end","pingUrl","url","response","status","error","message","readFileAsync","file","reader","FileReader","onerror","abort","DOMException","onload","result","readAsArrayBuffer"],"mappings":"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","sourcesContent":["import axios from 'axios'\r\nimport { Logger } from '@oceanprotocol/squid'\r\n\r\nexport function formatBytes(a: number, b: number) {\r\n    if (a === 0) return '0 Bytes'\r\n    const c = 1024\r\n    const d = b || 2\r\n    const e = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\r\n    const f = Math.floor(Math.log(a) / Math.log(c))\r\n\r\n    return parseFloat((a / Math.pow(c, f)).toFixed(d)) + ' ' + e[f]\r\n}\r\n\r\nexport function arraySum(array: number[]) {\r\n    return array.reduce((a, b) => a + b, 0)\r\n}\r\n\r\nexport function streamFiles(ipfs: any, files: any) {\r\n    return new Promise((resolve, reject) => {\r\n        const stream = ipfs.addReadableStream({\r\n            wrapWithDirectory: true\r\n            // progress: (length: number) =>\r\n            //     setFileSizeReceived(formatBytes(length, 0))\r\n        })\r\n\r\n        stream.on('data', (data: any) => {\r\n            Logger.log(`Added ${data.path} hash: ${data.hash}`)\r\n            // The last data event will contain the directory hash\r\n            if (data.path === '') resolve(data.hash)\r\n        })\r\n\r\n        stream.on('error', reject)\r\n        stream.write(files)\r\n        stream.end()\r\n    })\r\n}\r\n\r\nexport async function pingUrl(url: string) {\r\n    try {\r\n        const response = await axios(url)\r\n        if (response.status !== 200) Logger.error(`Not found: ${url}`)\r\n\r\n        Logger.log(`File found: ${url}`)\r\n        return true\r\n    } catch (error) {\r\n        Logger.error(error.message)\r\n    }\r\n    return false\r\n}\r\n\r\nexport function readFileAsync(file: File) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n        reader.onerror = () => {\r\n            reader.abort()\r\n            reject(new DOMException('Problem parsing input file.'))\r\n        }\r\n        reader.onload = () => {\r\n            resolve(reader.result)\r\n        }\r\n        reader.readAsArrayBuffer(file)\r\n    })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}